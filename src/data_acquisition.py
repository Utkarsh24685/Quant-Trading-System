# -*- coding: utf-8 -*-
"""Data Acquisition.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/11mZ6ONVW2hsxkQcjYVNqufVg6kSz_uKw

# Data Acquisition & Engineering  
## Quantitative Trading System (NIFTY 50)

**Objective:**  
To acquire, clean, and structure 1 year of daily market data required for building a complete quantitative trading system involving:
- Data engineering
- Feature engineering
- Regime detection
- Algorithmic strategy development
- Machine learning and statistical analysis

**Market:** Indian Equity & Derivatives Market (NSE)  
**Instruments:** NIFTY 50 Spot, NIFTY Futures, NIFTY Options  
**Data Period:** 14 January 2025 – 14 January 2026

## Why Daily Data Instead of 5-Minute Interval Data?

Although intraday (5-minute) data is commonly used in high-frequency trading systems, this project intentionally uses **daily data** for the following reasons:

### 1. Strategy Horizon Alignment
This project focuses on:
- Market regime detection
- Medium-term trend identification
- Derivatives positioning analysis
- Statistical and ML-based signal generation  

Daily data is more appropriate for capturing **structural market behavior** rather than short-term noise.

### 2. Noise Reduction
Intraday data contains significant microstructure noise caused by:
- Order book fluctuations
- Short-term liquidity imbalances
- High transaction costs impact  

Daily aggregation improves signal stability and statistical robustness.

### 3. Data Reliability & Reproducibility
- NSE does not officially provide clean intraday historical derivatives data
- Daily NSE historical data and F&O bhavcopies are **official, reliable, and reproducible**
- This ensures transparency and auditability of the research

### 4. Computational Efficiency
Daily data allows:
- Faster feature engineering
- Easier regime clustering
- Efficient ML model training without overfitting

### 5. Realistic Retail Quant Constraints
Most retail and academic quant research in Indian markets operates on daily data due to:
- API limitations
- Cost constraints
- Data availability

> Hence, daily data is sufficient and appropriate for building a robust end-to-end quantitative trading system.
"""

import pandas as pd
import numpy as np
import os
from datetime import datetime

"""# NIFTY 50 Spot Data Acquisition (Daily)

This notebook combines daily NSE index snapshot files into a single
clean NIFTY 50 daily OHLCV dataset.

**Input:**
- 249 daily raw NSE index CSV files (one file per trading day)

**Output:**
- nifty_spot_daily.csv

Only the **NIFTY 50** index is retained.

"""

import os

RAW_SPOT_PATH = "/content/raw spot"

files = [f for f in os.listdir(RAW_SPOT_PATH) if f.endswith(".csv")]
print("Total raw spot files found:", len(files))

files[:5]

import pandas as pd

dfs = []

for file in sorted(files):
    file_path = os.path.join(RAW_SPOT_PATH, file)
    df = pd.read_csv(file_path)
    dfs.append(df)

combined_spot_df = pd.concat(dfs, ignore_index=True)

combined_spot_df.head()

combined_spot_df.columns

nifty50_df = combined_spot_df[
    combined_spot_df['Index Name'].str.strip() == 'Nifty 50'
].copy()

print("Rows after filtering Nifty 50:", nifty50_df.shape)
nifty50_df.head()

nifty50_df['Index Date'] = pd.to_datetime(
    nifty50_df['Index Date'],
    dayfirst=True,
    errors='coerce'
)

nifty50_df = nifty50_df.sort_values('Index Date')

print(nifty50_df['Index Date'].min())
print(nifty50_df['Index Date'].max())

for col in nifty50_df.columns:
    print(f"'{col}'")

nifty50_df.columns = nifty50_df.columns.str.strip()

nifty50_df = nifty50_df[[
    'Index Date',
    'Open Index Value',
    'High Index Value',
    'Low Index Value',
    'Closing Index Value',
    'Volume'
]]

nifty50_df = nifty50_df.rename(columns={
    'Index Date': 'date',
    'Open Index Value': 'open',
    'High Index Value': 'high',
    'Low Index Value': 'low',
    'Closing Index Value': 'close',
    'Volume': 'volume'
})

nifty50_df = nifty50_df.reset_index(drop=True)

nifty50_df.to_csv("nifty_spot_daily.csv", index=False)

"""## NIFTY 50 Spot Data – Final Dataset

- Frequency: Daily
- Period: 14 Jan 2025 – 14 Jan 2026
- Source: NSE Historical Index Data
- Rows: One row per trading day
- Fields: Open, High, Low, Close, Volume

This dataset serves as the base market reference for:
- Return calculations
- Volatility estimation
- Market regime detection
- Benchmarking derivative strategies

---

# NIFTY Futures Data Acquisition (Daily)

This notebook constructs a **continuous daily NIFTY Index Futures dataset**
using NSE F&O bhavcopy files.

### Objective
- Extract **NIFTY Index Futures (FUTIDX)**
- Select **near-month contract**
- Handle **monthly expiry rollover**
- Create a clean daily futures time series

### Data Details
- Source: NSE F&O Bhavcopy
- Frequency: Daily
- Period: 14 Jan 2025 – 14 Jan 2026

### Output
- `nifty_futures_daily.csv`
"""

import pandas as pd
import os

RAW_FUTURE_PATH = "/content/raw future"

files = sorted([
    os.path.join(RAW_FUTURE_PATH, f)
    for f in os.listdir(RAW_FUTURE_PATH)
    if f.endswith(".csv")
])

print("Total bhavcopy files found:", len(files))

dfs = []

for file in files:
    df = pd.read_csv(file)
    df.columns = df.columns.str.strip()  # Clean column names
    dfs.append(df)

fno_df = pd.concat(dfs, ignore_index=True)
fno_df.head()

fno_df.columns

fut_df = fno_df[
    (fno_df['INSTRUMENT'] == 'FUTIDX') &
    (fno_df['SYMBOL'] == 'NIFTY')
].copy()

print("Rows after filtering FUTIDX NIFTY:", fut_df.shape)
fut_df.head()

fut_df['TIMESTAMP'] = pd.to_datetime(fut_df['TIMESTAMP'], dayfirst=True)
fut_df['EXPIRY_DT'] = pd.to_datetime(fut_df['EXPIRY_DT'], dayfirst=True)

fut_df = fut_df.sort_values(['TIMESTAMP', 'EXPIRY_DT'])

# Create continuous near-month futures series
fut_near = fut_df.groupby('TIMESTAMP').first().reset_index()

print(type(fut_near))
print(fut_near.shape)

fut_near = fut_near[[
    'TIMESTAMP',
    'OPEN',
    'HIGH',
    'LOW',
    'CLOSE',
    'CONTRACTS',
    'OPEN_INT'
]]

fut_near = fut_near.rename(columns={
    'TIMESTAMP': 'date',
    'OPEN': 'open',
    'HIGH': 'high',
    'LOW': 'low',
    'CLOSE': 'close',
    'CONTRACTS': 'volume',
    'OPEN_INT': 'open_interest'
})

fut_near = fut_near.reset_index(drop=True)

fut_near.info()

fut_near.head()

fut_near.to_csv("nifty_futures_daily.csv", index=False)

"""## NIFTY Futures – Final Dataset

- Instrument: NIFTY Index Futures (FUTIDX)
- Contract Type: Near-Month Continuous Futures
- Frequency: Daily
- Period: 14 Jan 2025 – 14 Jan 2026

### Fields
- Open, High, Low, Close
- Volume (Contracts Traded)
- Open Interest

### Usage in Quant System
- Futures-spot trend confirmation
- Open interest based position analysis
- Regime and momentum validation
- Strategy signal filtering

---

# NIFTY Options Data Acquisition (Daily)

This notebook constructs a **daily NIFTY index options dataset**
from NSE F&O bhavcopy files.

### Objective
- Extract NIFTY index options (OPTIDX)
- Select near-month expiry
- Retain ATM, ATM ±1, ATM ±2 strikes
- Include both Call and Put options
- Build a clean daily options dataset

### Data Source
- NSE F&O Bhavcopy
- Frequency: Daily
- Period: 14 Jan 2025 – 14 Jan 2026

### Output
- nifty_options_daily.csv
"""

import pandas as pd
import os

RAW_FUTURE_PATH = "/content/raw future"

files = sorted([
    os.path.join(RAW_FUTURE_PATH, f)
    for f in os.listdir(RAW_FUTURE_PATH)
    if f.endswith(".csv")
])

dfs = []
for file in files:
    df = pd.read_csv(file)
    df.columns = df.columns.str.strip()
    dfs.append(df)

fno_df = pd.concat(dfs, ignore_index=True)

opt_df = fno_df[
    (fno_df['INSTRUMENT'] == 'OPTIDX') &
    (fno_df['SYMBOL'] == 'NIFTY')
].copy()

print("Total option rows:", opt_df.shape)

opt_df['TIMESTAMP'] = pd.to_datetime(opt_df['TIMESTAMP'], dayfirst=True)
opt_df['EXPIRY_DT'] = pd.to_datetime(opt_df['EXPIRY_DT'], dayfirst=True)

opt_df = opt_df.sort_values(['TIMESTAMP', 'EXPIRY_DT'])
opt_df = opt_df.groupby(['TIMESTAMP', 'STRIKE_PR', 'OPTION_TYP']).first().reset_index()

spot_df = pd.read_csv("nifty_spot_daily.csv")
spot_df['date'] = pd.to_datetime(spot_df['date'])

opt_df = opt_df.merge(
    spot_df[['date', 'close']],
    left_on='TIMESTAMP',
    right_on='date',
    how='left'
)

import numpy as np

def get_atm(price, interval=50):
    if pd.isna(price):
        return np.nan
    return round(price / interval) * interval

opt_df['ATM'] = opt_df['close'].apply(get_atm)

opt_df['strike_diff'] = opt_df['STRIKE_PR'] - opt_df['ATM']

opt_df['ATM'].isna().sum()

opt_df = opt_df.dropna(subset=['ATM'])

opt_df = opt_df[
    opt_df['strike_diff'].isin([-100, -50, 0, 50, 100])
]

opt_df = opt_df[[
    'TIMESTAMP',
    'EXPIRY_DT',
    'OPTION_TYP',
    'STRIKE_PR',
    'CLOSE',
    'CONTRACTS',
    'OPEN_INT'
]]

opt_df = opt_df.rename(columns={
    'TIMESTAMP': 'date',
    'EXPIRY_DT': 'expiry',
    'OPTION_TYP': 'option_type',
    'STRIKE_PR': 'strike',
    'CLOSE': 'close_price',
    'CONTRACTS': 'volume',
    'OPEN_INT': 'open_interest'
})

opt_df = opt_df.reset_index(drop=True)
opt_df.to_csv("nifty_options_daily.csv", index=False)

"""## NIFTY Options – Final Dataset

- Instrument: NIFTY Index Options (OPTIDX)
- Expiry: Near-month
- Strikes: ATM, ATM ±1, ATM ±2
- Option Types: Call (CE), Put (PE)
- Frequency: Daily

### Usage in Quant System
- Market sentiment analysis (PCR)
- Options positioning analysis
- Volatility regime confirmation
- Signal filtering for futures strategies

---



---
"""